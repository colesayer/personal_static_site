{"version":3,"sources":["webpack:///path---drawing-in-react-1d221b01d769f6d484e4.js","webpack:///./.cache/json/drawing-in-react.json"],"names":["webpackJsonp","339","module","exports","data","markdownRemark","html","frontmatter","date","path","title","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,g6JAAmyJC,aAAyKC,KAAA,oBAAAC,KAAA,oBAAAC,MAAA,sBAAmFC","file":"path---drawing-in-react-1d221b01d769f6d484e4.js","sourcesContent":["webpackJsonp([178759478026549],{\n\n/***/ 339:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>I wanted to check out the <code>&#x3C;canvas></code> element in JS and see how it might be utilized in a React environment. There are some supposedly great libraries like Konva.js and its sibling React Konva for drawing complex graphics on canvas, but then I read arguments for using an <code>&#x3C;svg></code> element instead, which deals better with Reacts component lifecycles and, because its vector based rather than rasterized, doesn’t pixelate if you scale up.</p>\\n<p><strong>Data Structure for React</strong>\\n</br>\\n</br>\\n<a href=\\\"http://res.cloudinary.com/dwnehv6tb/image/upload/v1515225386/1_pc2m1i.jpg\\\">\\n<img src=\\\"http://res.cloudinary.com/dwnehv6tb/image/upload/v1515225386/1_pc2m1i.jpg\\\"\\n     alt=\\\"blender exec\\\"\\n     style=\\\"width: 100%\\\" />\\n</a>\\n</br>\\n</br>\\nThe canvas has a state isDrawing with a default of false, when you start drawing in the app this will change to true.</p>\\n<p>We pass a property called lines to drawing, lines will be a list of points on an x and y map. We’ll use immutable.js to handle the lines. Immutable.js deals with persistant immutable data structures. It’s a really interesting library worthy of its own blog post. Immutable makes it so that when you alter a collection with something like push, it automatically makes a copy of the array and returns a new array. It was made by Facebook and is somehow optimized in the same way React uses a Virtual Dom to render only necessary changes.</p>\\n<p><strong>So to our program:</strong></p>\\n<p>First we build our Canvas component with a div drawArea that has two event listeners:</p>\\n<pre><code>import React, { Component } from 'react';\\nclass Canvas extends Component{\\n  state = {\\n    isDrawing: false,\\n    lines: new Immutable.list()\\n  }\\nhandleMouseDown = () => {\\n}\\nhandleMouseUp = () => {\\n}\\n\\nrender(){\\n  return(\\n    &#x3C;div ref=\\\"drawArea\\\" onMouseDown={this.handleMouseDown} onMouseMove={this.handleMouseMove}/>\\n    )\\n  }\\n}\\nexport default React\\n</code></pre>\\n<p>The handleMouseDown method listens for the “main” mouse button. It sets the isDrawing state to true and pushes the coordinates of the mouse event to the array of lines.</p>\\n<pre><code>handleMouseDown = (event) => {\\n    if (event.button !== 0) return\\nconst point = this.relativeCoordinatesForEvent(event);\\nthis.setState(prevState => {\\n      return {\\n        lines: prevState.lines.push(new Immutable.List([point])),\\n        isDrawing: true,\\n      }\\n    })\\n  }\\n</code></pre>\\n<p>Since those coordinates start on the top/left of the browser and not our DrawArea, we will subtract the <code>top</code> and <code>left</code> position of the event relative to it’s coordinates on the page. The <code>getBoundingClientRect()</code> function returns the size of the drawing area and its position relative to the viewport.</p>\\n<pre><code>relativeCoordinatesForEvent(event) {\\n  const boundingRect = this.refs.drawArea.getBoundingClientRect();\\n\\n  return new Immutable.Map({\\n    x: event.clientX - boundingRect.left,\\n    y: event.clientY - boundingRect.top,\\n  });\\n}\\n</code></pre>\\n<p>Our <code>handleMouseMove</code> method pushes the new point to the <code>lines</code> state in reference to its previous state. <code>updateIn()</code> is a function built into Immutable that returns a copy of the previous state and updates the copy with the specified value.</p>\\n<pre><code>handleMouseMove = (event) => {\\n    if (!this.state.isDrawing) {\\n      return;\\n    }\\n  const point = this.relativeCoordinatesForEvent(event);\\n  this.setState(prevState =>  ({\\n      lines: prevState.lines.updateIn([prevState.lines.size - 1],     line => line.push(point))\\n    }));\\n  }\\n</code></pre>\\n<p>At this point we have the canvas set up, we just need to add the ability to make and display a drawing.</p>\\n<pre><code>const Drawing = (props) => {\\n    return(\\n      &#x3C;svg className=\\\"drawing\\\">\\n        {props.lines.map((line, index) => (\\n          &#x3C;DrawingLine key={index} line={line} />\\n        ))}\\n      &#x3C;/svg>\\n    )\\n  }\\n</code></pre>\\n<p>The <code>&#x3C;svg></code> element is an XML-based vector image format. It has its own viewport and coordinate system. An example <code>&#x3C;svg></code> might look like:</p>\\n<pre><code>&#x3C;svg>\\n  &#x3C;path stroke=\\\"black\\\" d=\\\"M 0 0 L 200 100\\\" />\\n&#x3C;/svg>\\n</code></pre>\\n<p>which renders a black line from coordinates 0, 0 to 200, 100.</p>\\n<p>In the next functional component, we feed the Immutable list state from our Canvas, through Drawing, and down to its child the DrawingLine component. It interpolates the lines prop into paths.</p>\\n<pre><code>const DrawingLine = (props) => {\\n  const pathData = \\\"M \\\" + props.line\\n    .map(p => {\\n      return `${p.get('x')} ${p.get('y')}`\\n    })\\n    .join(\\\" L \\\");\\n    console.log(\\\"in DrawingLine\\\", pathData)\\nreturn &#x3C;path className=\\\"path\\\" d={pathData} />;\\n}\\n</code></pre>\\n<p>That’s it!</p>\\n<p>We fire it up and……</p>\\n<img src=\\\"https://media.giphy.com/media/xT1R9S8sHDNhd4YKME/giphy.gif\\\" width=\\\"100%\\\"/>\",\"frontmatter\":{\"date\":\"November 09, 2017\",\"path\":\"/drawing-in-react\",\"title\":\"Drawing in React\"}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---drawing-in-react-1d221b01d769f6d484e4.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>I wanted to check out the <code>&#x3C;canvas></code> element in JS and see how it might be utilized in a React environment. There are some supposedly great libraries like Konva.js and its sibling React Konva for drawing complex graphics on canvas, but then I read arguments for using an <code>&#x3C;svg></code> element instead, which deals better with Reacts component lifecycles and, because its vector based rather than rasterized, doesn’t pixelate if you scale up.</p>\\n<p><strong>Data Structure for React</strong>\\n</br>\\n</br>\\n<a href=\\\"http://res.cloudinary.com/dwnehv6tb/image/upload/v1515225386/1_pc2m1i.jpg\\\">\\n<img src=\\\"http://res.cloudinary.com/dwnehv6tb/image/upload/v1515225386/1_pc2m1i.jpg\\\"\\n     alt=\\\"blender exec\\\"\\n     style=\\\"width: 100%\\\" />\\n</a>\\n</br>\\n</br>\\nThe canvas has a state isDrawing with a default of false, when you start drawing in the app this will change to true.</p>\\n<p>We pass a property called lines to drawing, lines will be a list of points on an x and y map. We’ll use immutable.js to handle the lines. Immutable.js deals with persistant immutable data structures. It’s a really interesting library worthy of its own blog post. Immutable makes it so that when you alter a collection with something like push, it automatically makes a copy of the array and returns a new array. It was made by Facebook and is somehow optimized in the same way React uses a Virtual Dom to render only necessary changes.</p>\\n<p><strong>So to our program:</strong></p>\\n<p>First we build our Canvas component with a div drawArea that has two event listeners:</p>\\n<pre><code>import React, { Component } from 'react';\\nclass Canvas extends Component{\\n  state = {\\n    isDrawing: false,\\n    lines: new Immutable.list()\\n  }\\nhandleMouseDown = () => {\\n}\\nhandleMouseUp = () => {\\n}\\n\\nrender(){\\n  return(\\n    &#x3C;div ref=\\\"drawArea\\\" onMouseDown={this.handleMouseDown} onMouseMove={this.handleMouseMove}/>\\n    )\\n  }\\n}\\nexport default React\\n</code></pre>\\n<p>The handleMouseDown method listens for the “main” mouse button. It sets the isDrawing state to true and pushes the coordinates of the mouse event to the array of lines.</p>\\n<pre><code>handleMouseDown = (event) => {\\n    if (event.button !== 0) return\\nconst point = this.relativeCoordinatesForEvent(event);\\nthis.setState(prevState => {\\n      return {\\n        lines: prevState.lines.push(new Immutable.List([point])),\\n        isDrawing: true,\\n      }\\n    })\\n  }\\n</code></pre>\\n<p>Since those coordinates start on the top/left of the browser and not our DrawArea, we will subtract the <code>top</code> and <code>left</code> position of the event relative to it’s coordinates on the page. The <code>getBoundingClientRect()</code> function returns the size of the drawing area and its position relative to the viewport.</p>\\n<pre><code>relativeCoordinatesForEvent(event) {\\n  const boundingRect = this.refs.drawArea.getBoundingClientRect();\\n\\n  return new Immutable.Map({\\n    x: event.clientX - boundingRect.left,\\n    y: event.clientY - boundingRect.top,\\n  });\\n}\\n</code></pre>\\n<p>Our <code>handleMouseMove</code> method pushes the new point to the <code>lines</code> state in reference to its previous state. <code>updateIn()</code> is a function built into Immutable that returns a copy of the previous state and updates the copy with the specified value.</p>\\n<pre><code>handleMouseMove = (event) => {\\n    if (!this.state.isDrawing) {\\n      return;\\n    }\\n  const point = this.relativeCoordinatesForEvent(event);\\n  this.setState(prevState =>  ({\\n      lines: prevState.lines.updateIn([prevState.lines.size - 1],     line => line.push(point))\\n    }));\\n  }\\n</code></pre>\\n<p>At this point we have the canvas set up, we just need to add the ability to make and display a drawing.</p>\\n<pre><code>const Drawing = (props) => {\\n    return(\\n      &#x3C;svg className=\\\"drawing\\\">\\n        {props.lines.map((line, index) => (\\n          &#x3C;DrawingLine key={index} line={line} />\\n        ))}\\n      &#x3C;/svg>\\n    )\\n  }\\n</code></pre>\\n<p>The <code>&#x3C;svg></code> element is an XML-based vector image format. It has its own viewport and coordinate system. An example <code>&#x3C;svg></code> might look like:</p>\\n<pre><code>&#x3C;svg>\\n  &#x3C;path stroke=\\\"black\\\" d=\\\"M 0 0 L 200 100\\\" />\\n&#x3C;/svg>\\n</code></pre>\\n<p>which renders a black line from coordinates 0, 0 to 200, 100.</p>\\n<p>In the next functional component, we feed the Immutable list state from our Canvas, through Drawing, and down to its child the DrawingLine component. It interpolates the lines prop into paths.</p>\\n<pre><code>const DrawingLine = (props) => {\\n  const pathData = \\\"M \\\" + props.line\\n    .map(p => {\\n      return `${p.get('x')} ${p.get('y')}`\\n    })\\n    .join(\\\" L \\\");\\n    console.log(\\\"in DrawingLine\\\", pathData)\\nreturn &#x3C;path className=\\\"path\\\" d={pathData} />;\\n}\\n</code></pre>\\n<p>That’s it!</p>\\n<p>We fire it up and……</p>\\n<img src=\\\"https://media.giphy.com/media/xT1R9S8sHDNhd4YKME/giphy.gif\\\" width=\\\"100%\\\"/>\",\"frontmatter\":{\"date\":\"November 09, 2017\",\"path\":\"/drawing-in-react\",\"title\":\"Drawing in React\"}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/drawing-in-react.json\n// module id = 339\n// module chunks = 178759478026549"],"sourceRoot":""}